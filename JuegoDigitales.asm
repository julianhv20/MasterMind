       .ORIG    x3000

	;Numero de digitos

START 	LD      R0,MSGT0
        PUTS   	 
	LD	R0,MSGTI
	PUTS
	BR	 DIGITOS

STRINGNT  .FILL	STRINGN
NT	  .FILL	N
MSGT1	  .FILL MSG1
MSGT0	  .FILL MSG0
MSGTI	  .FILL MSGI
MSGT4	  .FILL MSG4
COPYR7T1  .FILL COPYR7
STRINGNT1  .FILL STRINGN1
TT	   .FILL T
MSGT2	  .FILL MSG2
MSGT5	  .FILL MSG5


DIGITOS	LD      R0,MSGT1
        PUTS
	LD  	R5,NT		;DIGITOS
	LD      R2,STRINGNT
	AND	 R3,R3,#0
	ADD 	 R3,R3,#-1
	JSR 	INGRESS
	AND 	R1,R1,#0
	AND 	R6,R6,#0
	LD      R0,STRINGNT	;DIRECCIÓN DONDE ALMACENÉ LOS NUMEROS QUE INGRESARON PARA IMPRIMIR
	ADD 	R1,R1,#11	;MINIMO
	ADD 	R6,R6,#15	;MAXIMO
	AND 	R5,R5,#0
	LD  	R5,NT           ;DIRECCIÓN DE N EN EL REGISTRO R5
	JSR	EDIGI		;FUNCION PARA SABER SI ESTÁ EN EL RANGO [04:15]
	ADD	R1,R1,#0        ;SI R1 ES 0 SE TUVO UN ERROR POR LO QUE VOLVEMOS A DIGITOS
	BRz	DIGITOS

INTENTOS	LD      R0,MSGT2         ;INTENTOS
        PUTS
	LD  	R5,TT
	LD      R2,STRINGNT1
	AND	R3,R3,#0
	ADD 	R3,R3,#-1
	JSR 	INGRESS
	AND 	R1,R1,#0
	AND 	R6,R6,#0
	LD      R0,STRINGNT1	;DIRECCIÓN DONDE ALMACENÉ LOS NUMEROS QUE INGRESARON PARA IMPRIMIR
	ADD 	R1,R1,#7	;MINIMO
	ADD 	R6,R6,#12	;MAXIMO
	AND 	R5,R5,#0
	LD  	R5,TT		;DIRECCIÓN DE T EN EL REGISTRO R5
	JSR	EDIGI		;FUNCION PARA SABER SI ESTÁ EN EL RANGO [04:12]
	ADD	R1,R1,#0	;SI R1 ES 0 SE TUVO UN ERROR POR LO QUE VOLVEMOS A DIGITOS
	BRz	INTENTOS
	BR	CODIGOP		;SI NO HUBIERON ERRORES PROCEDEMOS A LA PARTE DEL PROGRAMADOR

;;;;;;;;;;;;;FUNCIÓN PRA SABER SI ESTÁ EN EL RANGO DESEADO E IMPRIMIR
;
EDIGI		ST  R7,COPYR7T1
		AND R4,R4,#0
		LDR R3,R5,#0	;VALOR DE N
		NOT R4,R6
		ADD R4,R4,#1
		ADD R4,R3,R4
		BRp ERRORD
		ADD R4,R4,R1
		BRn ERRORD     
        	PUTS
		LD  R7,COPYR7T1
		RET
 
	ERRORD	PUTS
		LD      R0,MSGT4     ;ERROR
        	PUTS 
		AND	R1,R1,#0
		LD	R7,COPYR7T1		       
		RET	
;

;;;;;;;;;;;;;FUNCIÓN PARA INGRESAR DOS DIGITOS Y GUARDAR LOS DOS DIGITOS EN "N" O "T"
;
INGRESS	ST	R7,COPYR7T1
LOOP    GETC                    ;; Get a character and store it into R0
	STR      R0,R2,#0
	AND 	 R6,R6,#0
	ADD	 R3,R3,#1
	BRp	 VALORN
	JSR	 FUNC48
	NOT	 R6,R1
	ADD	 R6,R6,#1
	ADD	 R6,R0,R6
	BRz	 CERO
	ADD	 R6,R6,#-1
	BRZ	 DIEZ
	BR	 ERRORD

CERO	AND	 R4,R4,#0
	STR	 R4,R2,#5
	ADD	 R2,R2,#1
	BR	 LOOP

DIEZ	AND	 R4,R4,#0
	ADD	 R4,R4,#10
	STR	 R4,R2,#5
	ADD	 R2,R2,#1
	BR	 LOOP	

VALORN	JSR FUNC48
	AND R6,R6,#0
	NOT R6,R1
	ADD R6,R6,#1
	ADD R6,R0,R6
	AND R4,R4,#0
	LDR R4,R2,#4           ;;Suma 
	ADD R4,R4,R6
	ADD R2,R2,#5
	STR R4,R5,#0            ;CARGAMOS EL VALOR DE N O T
	LD	R7,COPYR7T1
	RET
;

;;;;;;;;;;;;CODIGO PROGRAMADOR


CODIGOP	LD      R0,MSGT3
        PUTS 
	BR	 CODING
	

DATAT	  .FILL	 DATA
MSGT3	  .FILL MSG3
MSGT6	  .FILL MSG6
MSGT7	  .FILL MSG7
MSGT8	  .FILL MSG8
DATAC	.FILL	 DATAU
ASTER	.FILL	ASTE

SALTO	BR	DIGITOS

CODING	LD      R0,DATAT      ;; 
	AND	 R3,R3,#0
	AND	 R5,R5,#0
	LD	 R2,NT         ;posición de memoria de N
	LDR	 R3,R2,#0      ;AGREGO EL VALOR DE N En el registro r3
	LD      R2,DATAT      ;posicion de memoria del codigo
	ADD	 R5,R5,R3	;registro con el valor de N
	JSR	 RANGEIN

	ADD	 R1,R1,#0
	BRz	 COMPARACION1
	ADD	 R1,R1,#0
	BRnp	 CODIGOP
	
	
;;;;;;
RANGEIN ST	R7,COPYR7T1
LOOPP2  GETC
	AND	 R1,R1,#0
	AND	 R6,R6,#0
	AND      R5,R5,#0
	JSR	 FUNC48
	ADD	 R1,R1,#15
	ADD	 R1,R1,#6
	ADD	 R6,R6,R1	;R6 CONTIENE EL VALOR DE 69 EQUIVALENTE A "E" EN ASCII
	ADD	 R5,R5,#5	;R5 CONTIENE 69-65+1=5, ESTOS DOS VALORES ME DEFINEN EL RANGO ENTRE [A:E]	
	JSR	 RANGE
	ADD	 R6,R6,#0
	BRn	 DIGIERROR    
	ADD	 R4,R4,#0
	BRp	 INGRESO
	JSR	 FUNC48
	AND	 R6,R6,#0
	ADD	 R1,R1,#9		
	ADD      R6,R6,R1	;R6 CONTIENE EL VALOR DE 57
	AND      R5,R5,#0
	ADD	 R5,R5,#10	;R5 CONTIENE 57-48+1=10, ESTOS DOS VALORES ME DEFINEN EL RANGO ENTRE [0:9]
	JSR	 RANGE			;FUNCIÓN RANGE TIENE DOS SALIDAS, R4 Y R6
	ADD	 R6,R6,#0
	BRn	 DIGIERROR
	ADD	 R4,R4,#0
	BRp	 INGRESO         
		                     
INGRESO	STR      R0,R2,#0
	ADD	 R2,R2,#1      ; SE MUEVE R2 PARA IR INGRESANDO EN LA MEMORIA
	ADD	 R3,R3,#-1
	BRp	 LOOPP2        ;SE MANTIENE HASTA INGRESAR TODOS LOS NUMEROS DEL CODIGO
	AND	 R1,R1,#0
	LD	R7,COPYR7T1
	RET

DIGIERROR	LD      R0,MSGT7     ;ERROR SI EL NUMERO NO ESTÁ EN EL RANGO SELCCIONADO POR EL PROGRAMADOR 0123456789ABCDE
        	PUTS 
	LD	R7,COPYR7T1	
	RET
;;;;;;;;;

COMPARACION1	LD	 R2,NT         ;posición de memoria de N
		LDR	 R3,R2,#0
		AND      R0,R0,#0
		JSR	 FUNC48		;ASTE IMPRIME ASTEISCOS N VECES
		ADD	 R0,R1,#-6
		LD	 R2,ASTER
		STR	 R0,R2,#0
	ASTERIS	LD	R0,ASTER
		PUTS
		ADD	 R3,R3,#-1
		BRp	 ASTERIS	
		;LD      R0,DATAT        ;;;;;;;IMPRIME EL CODIGO SECRETO
		;PUTS


		AND R0,R0,#0
		AND R1,R1,#0
		AND R3,R3,#0       ;inicializamos registros en 0 para utilizarlos
		AND R4,R4,#0
		AND R6,R6,#0
		LD  R2,NT         ;posición de memoria de N
		LDR R5,R2,#0      ;AGREGO EL VALOR DE N En el registro r3
		LD R2,DATAT
		ADD R2,R2,#-1
		
		ADD R1,R1,R5        ;;R1 y R5 almacena numero de digitos

	CICLO1	ADD R2,R2,#1
		LDR R3,R2,#0	    ;;R2 Y R4 ALAMACENAN POSICIONES DE MEMORIA PARA COMPARAR DIGITO A DIGITO        12345
		LD  R4,NT	    ;;R3 Y R6 ALMACENA LOS VALORES DE NUMERO QUE COMPARAMOS                         
		LDR R5,R4,#0        ;VUELVO A CARGAR A R5 EL VALOR DE N YA QUE EN CICLO2 FUE ALTERADO  
		LD R4,DATAT         
		ADD R4,R4,#0        ;;LE CARGO A R4 LA DIRRECCION DE MEMORIA DONDE INICIA EL CODIGO
		ADD R1,R1,#-1       ;SI R1 ES IGUAL A 0 YA COMPARO TODOS LOS DIGITOS POR LO QUE SALTA A CONT
		BRZ COPIAT 
   
	CICLO2	LDR R6,R4,#0
		NOT R0,R4
		ADD R0,R0,#1          ;VERIFICA QUE NO SE COMPARE EL MISMO ESPACIO DE MEMORIA
		ADD R0,R2,R0          ;RESTO LOS DOS PUNTEROS QUE ESTOY UTILIZANDO			      
		BRZ IGUALM            ;SI LA RESTA ES 0 SALTO A IGUALM
		
		AND R0,R0,#0

		NOT R0,R6
		ADD R0,R0,#1	      ;RESTA PARA COMPARAR SI UN DIGITO ES IGUAL AL OTRO
		ADD R0,R3,R0          ;SI LA RESTA ES 0, SALTA A DIGITOR
		BRZ DIGITOR

		ADD R4,R4,#1          ;AUMENTO EL PUNTERO R4 PARA COMPARAR CON OTRO NUMERO         
		ADD R5,R5,#-1         ;
		BRZ CICLO1            ;SI R5 ES 0 YA TERMINO DE COMPARAR UN DIGITO CON TODOS LOS DIGITOS Y VUELVE AL CICLO1
		BR  CICLO2	      ;VUELVE A CICLO2 SI NO HA TERMINADO DE COMPARAR UN DIGITO CON LOS OTROS

IGUALM		ADD R4,R4,#1	     ;SI SE VAN A COMPARAR LOS MISMOS ESPACIOS DE MEMORIA LE SUMAMOS UNO A R4 PARA SEGUIR CON EL SGUIENTE DIGITO
		ADD R5,R5,#-1
		BR  CICLO2

DIGITOR		LD      R0,MSGT6     ;MUESTRA MENSAJE SI UN DIGITO ES REPETIDO EN EL CODIGO
        	PUTS 
		BR	 CODIGOP


CTT     .FILL  CT
	
	
COPIAT   JSR	FUNC48
	 ADD    R1,R1,#1
	 LD	R2,CTT
	 STR	R1,R2,#0


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;INGRESO USUARIO
	
USUING	LD      R0,MSGT8
        PUTS 
	LD      R0,DATAC     ;; 
	AND	 R3,R3,#0
	AND	 R5,R5,#0
	LD	 R2,NT         ;posición de memoria de N
	LDR	 R3,R2,#0      ;AGREGO EL VALOR DE N En el registro r3
	LD      R2,DATAC      ;posicion de memoria del codigo
	ADD	 R5,R5,R3	;registro con el valor de N
	JSR	 RANGEIN
	LD      R0,DATAC
	PUTS
	ADD	 R1,R1,#0
	BRz	 COMP2
	ADD	 R1,R1,#0
	BRnp	 USUING


COMP2		AND R0,R0,#0
		AND R1,R1,#0
		AND R3,R3,#0       ;inicializamos registros en 0 para utilizarlos
		AND R4,R4,#0
		AND R6,R6,#0
		LD  R2,NT         ;posición de memoria de N
		LDR R5,R2,#0      ;AGREGO EL VALOR DE N En el registro r3
		LD R2,DATAC
		ADD R2,R2,#-1
		
		ADD R1,R1,R5        ;;R1 y R5 almacena numero de digitos

	CICLO12	ADD R2,R2,#1
		LDR R3,R2,#0	    ;;R2 Y R4 ALAMACENAN POSICIONES DE MEMORIA PARA COMPARAR DIGITO A DIGITO        12345
		LD  R4,NT	    ;;R3 Y R6 ALMACENA LOS VALORES DE NUMERO QUE COMPARAMOS                         
		LDR R5,R4,#0        ;VUELVO A CARGAR A R5 EL VALOR DE N YA QUE EN CICLO2 FUE ALTERADO  
		LD R4,DATAC         
		ADD R4,R4,#0        ;;LE CARGO A R4 LA DIRRECCION DE MEMORIA DONDE INICIA EL CODIGO
		ADD R1,R1,#-1       ;SI R1 ES IGUAL A 0 YA COMPARO TODOS LOS DIGITOS POR LO QUE SALTA A CONT
		BRZ CONTIN
   
	CICLO22	LDR R6,R4,#0
		NOT R0,R4
		ADD R0,R0,#1          ;VERIFICA QUE NO SE COMPARE EL MISMO ESPACIO DE MEMORIA
		ADD R0,R2,R0          ;RESTO LOS DOS PUNTEROS QUE ESTOY UTILIZANDO			      
		BRZ IGUALM2            ;SI LA RESTA ES 0 SALTO A IGUALM
		
		AND R0,R0,#0
		NOT R0,R6
		ADD R0,R0,#1	      ;RESTA PARA COMPARAR SI UN DIGITO ES IGUAL AL OTRO
		ADD R0,R3,R0          ;SI LA RESTA ES 0, SALTA A DIGITOR
		BRZ DIGITOR2

		ADD R4,R4,#1          ;AUMENTO EL PUNTERO R4 PARA COMPARAR CON OTRO NUMERO         
		ADD R5,R5,#-1         ;
		BRZ CICLO12            ;SI R5 ES 0 YA TERMINO DE COMPARAR UN DIGITO CON TODOS LOS DIGITOS Y VUELVE AL CICLO1
		BR  CICLO22	      ;VUELVE A CICLO2 SI NO HA TERMINADO DE COMPARAR UN DIGITO CON LOS OTROS

IGUALM2		ADD R4,R4,#1	     ;SI SE VAN A COMPARAR LOS MISMOS ESPACIOS DE MEMORIA LE SUMAMOS UNO A R4 PARA SEGUIR CON EL SGUIENTE DIGITO
		ADD R5,R5,#-1
		BR  CICLO22

DIGITOR2	LD      R0,MSGT6     ;MUESTRA MENSAJE SI UN DIGITO ES REPETIDO EN EL CODIGO
        	PUTS 
		BR	 USUING


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

NTT	  .FILL	N
NC	  .BLKW 1       ;copia de N
TCC	  .FILL T
TC	  .BLKW 1       ;copia de T


	;CODIGO USUARIO

;;;;;;;LIMPIO LA MEMORIA DE CODIGO USUARIO Y CODIGO SECRETO
CLEAR		AND R1,R1,#0
		AND R2,R2,#0
		AND R3,R3,#0
		AND R4,R4,#0
		LD  R1,DATAT
		LD  R2,DATAC
		ADD R3,R3,15
	CICL	STR  R4,R1,#0
		STR  R4,R2,#0
		ADD R2,R2,#1
		ADD R1,R1,#1
		ADD R3,R3,#-1
		BRp CICL
		BR  SALTO
;;;;;;;;;;;

CONTIN	AND	R0,R0,#0
	AND 	R1,R1,#0	
	AND	 R3,R3,#0
	AND	 R5,R5,#0
	JSR	FUNC48
	LD	R0,PCT          
	STR	R1,R0,#0
	LD	R0,PIT
	STR	R1,R0,#0
	

	AND 	R1,R1,#0
	AND	R2,R2,#0
	AND	R3,R3,#0
	
	;HAGO UNA COPIA DE T QUE SE ALMACENA EN TC	
	LD	R1,TCC           ;OBTENEMOS LA DIRECCIÓN DE T
	LDR	R2,R1,#0	;CARGAMOS AL R2 LO QUE HAY EN T
	LEA     R3,TC		;OBTENEMOS LA DIRECCIÓN DE UN NCOPIA
	STR	R2,R3,#0	;CARGAMOS EL VALOR DE N, HACMEOS ESTO PARA EVITAR EL OFFSET

	;HAGO UNA COPIA DE N QUE SE ALMACENA EN NC
	LD	R1,NTT           ;OBTENEMOS LA DIRECCIÓN DE N
	LDR	R2,R1,#0	;CARGAMOS AL R2 LO QUE HAY EN N
	LEA     R3,NC		;OBTENEMOS LA DIRECCIÓN DE UN NCOPIA
	STR	R2,R3,#0	;CARGAMOS EL VALOR DE N, HACMEOS ESTO PARA EVITAR EL OFFSET
	BR      COPIAS

MSGT9	  .FILL MSG9
MSGT10	  .FILL MSG10
MSGT11	  .FILL MSG11
PCT	  .FILL	 PC		;direccion de posicion correcta
PIT	  .FILL	 PI           ;direccion de posicion incorrecta

PP	  .BLKW  1            ;posicion programador 
PU        .BLKW  1            ;posicion ususario


;
	FUNC48	AND	R6,R6,#0	;FUNCION PARA OBTENER EN R1 EL VALOR DE 48
		ADD	R6,R6,#4
		AND	R1,R1,#0
	NUM48	ADD	R1,R1,#10	;PC Y PI DEBEN TENER EL VALOR DE 48 YA QUE ESTE ES EL 0 EN ASCII
		ADD	R6,R6,#-1
		BRp	NUM48
		ADD	R1,R1,#8
		RET
;

;
	RANGE	AND	 R1,R1,#0        ;FUNCION RANGE NECESITA ALMACENAR EN R6 EL VALOR MAXIMO DEL RANGO Y EN R5 LA RESTA DEL MAXIMO-MINIMO DEL RANGO +1
		NOT	 R1,R6
		ADD	 R1,R1,#1       ;R1 ESTÁ CON EL VALOR DE -69
		ADD	 R4,R1,R0       ;RESTAMOS VALOR INGRESADO CON -69
		BRp	 ERRORC      ;SI ES POSITIVO ES UN VALOR MAYOR A 69 POR LO QUE SIGNIFICA QUE SE PASO DE LA E NUESTRO LIMITE SUPERIOR
		BR	 NERROR

	ERRORC	AND	 R6,R6,#0
		ADD	 R6,R6,#-1	
		RET
	
	NERROR	ADD	 R4,R4,R5	;SI SUMAMOS 5 Y EL VALOR ES POSITIVO INDICA QUE ESTÁ ENTRE [A:E]=[65:69]
		RET	 

;

COPYR7T .FILL    COPYR7
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	
DATACC	.FILL  DATA
DATATT	.FILL  DATAU
MSGT12	  .FILL MSG12

	COPIAS  AND 	R1,R1,#0
		AND	R2,R2,#0
		AND	R3,R3,#0
		AND	R6,R6,#0

		LD	R1,NTT           ;OBTENEMOS LA DIRECCIÓN DE N
		LDR	R2,R1,#0	;CARGAMOS AL R2 LO QUE HAY EN N
		LEA     R3,NC		;OBTENEMOS LA DIRECCIÓN DE UN NCOPIA
		STR	R2,R3,#0	;CARGAMOS EL VALOR DE N, HACMEOS ESTO PARA EVITAR EL OFFSET
		ADD	R6,R2,#1	;VALOR DE N+1	

		AND	R1,R1,#0
		AND	R2,R2,#0
		AND	R3,R3,#0	;INICIACILZAMOS REGISTROS
		AND	R4,R4,#0
		AND	R5,R5,#0

		;VERIFICACIMOS SI EL INTENTO DEL USUARIO ES IGUAL AL CODIGO

		LD	R2,DATATT	;DIRECCION DEL PRIMER DIGITO DEL PROGRAMADOR
		LD	R4,DATACC	;DIRECCIÓN DEL PRIMER DIGITO DEL USUARIO
	IGUALES LDR	R1,R2,#0	;CARGAMOS LAS ANTERIORES DIRECCIONES A DOS REGISTROS PARA COMPARAR
		LDR	R3,R4,#0	
		ADD	R6,R6,#-1	;DISMINUYE R6=N YA QUE ESTE ME INDICA CUANTOS DIGITOS SON Y CUANTAS VECES ME TENGO QUE DESPLAZAR A LA DERECHA
		BRz	FELICITACIONES	
		ADD	R2,R2,#1        ;AUMENTAMOS LAS DIRECCIONES PARA QUE EN EL OTRO CICLO COMPARE LOS SIGUIENTES DIGITOS
		ADD	R4,R4,#1
		NOT	R5,R1
		ADD	R5,R5,#1	; RESTAMOS DIGITO A DIGITO
		ADD	R5,R5,R3	;SI ES IGUAL A 0 SIGNIFICA QUE SON IGUALES Y PUEDE ESTAR GANANDO
		BRz	IGUALES

		;SEGUIMOS VERIFICANDO EL NUMERO DE DIGITOS EN POSICIÓN CORRECTA E INCORRECTA
		
		AND R0,R0,#0
		AND R1,R1,#0
		AND R3,R3,#0       ;inicializamos registros en 0 para utilizarlos
		AND R4,R4,#0
		AND R5,R5,#0
		AND R6,R6,#0
		AND R7,R7,#0
		LD  R5,NC	   ;CARGAMOS A R5 EL VALOR DE N
		LD R2,DATATT         ;DIRECCIÓN DEL PRIMER CARACTER DEL CODIGO DEL PROGRAMDOR EN R2
		ADD R2,R2,#-1
		
		ADD R1,R1,R5        ;;R1 y R5 almacena EL VALOR DE N
		ADD R1,R1,#1

	CICLOT1	ADD R2,R2,#1	    ;;R2 Y R4 ALAMACENAN POSICIONES DE MEMORIA PARA COMPARAR DIGITO A DIGITO
		LDR R3,R2,#0	    ;;R3 Y R6 ALMACENA LOS VALORES DE NUMERO QUE COMPARAMOS			    
		LD R5,NC   	    ;;VUELVO A CARGAR A R5 EL VALOR DE N YA QUE EN CICLO2 FUE ALTERADO  
		LD R4,DATACC        ;;DIRECCIÓN DEL PRIMER CARACTER DEL CODIGO DEL USUARIO EN R4
		ADD R1,R1,#-1       ;SI R1 ES IGUAL A 0 YA COMPARO TODOS LOS DIGITOS POR LO QUE SALTA A CONT
		BRZ IMT 
   
	CICLOT2	LDR R6,R4,#0	
		AND R0,R0,#0
		AND R7,R7,#0

		LD R7,DATATT
		NOT R0,R7
		ADD R0,R0,#1
		ADD R0,R2,R0         ;POSICIÓN DE CARACTER DEL CODIGO DEL PROGRAMADOR QUE ESTOY COMPARANDO
		LEA R7,PP
		STR R0,R7,#0

		AND R0,R0,#0
		AND R7,R7,#0
		LD R7,DATACC
		NOT R0,R7
		ADD R0,R0,#1
		ADD R0,R4,R0         ;POSICIÓN DE CARACTER DEL CODIGO DEL PROGRAMADOR QUE ESTOY COMPARANDO
		LEA R7,PU
		STR R0,R7,#0
		

		AND R0,R0,#0
		NOT R0,R6
		ADD R0,R0,#1	      ;RESTA PARA COMPARAR SI UN DIGITO ES IGUAL AL OTRO
		ADD R0,R3,R0          ;SI LA RESTA ES 0, SALTA A DIGITOR
		BRZ POSICION
      
		ADD R4,R4,#1          ;AUMENTO EL PUNTERO R4 PARA COMPARAR CON OTRO NUMERO         
		ADD R5,R5,#-1         ;
		BRZ CICLOT1            ;SI R5 ES 0 YA TERMINO DE COMPARAR UN DIGITO CON TODOS LOS DIGITOS Y VUELVE AL CICLO1
		BR  CICLOT2	      ;VUELVE A CICLO2 SI NO HA TERMINADO DE COMPARAR UN DIGITO CON LOS OTROS

POSICION	AND R0,R0,#0
		AND R7,R7,#0
		LD  R0,PP
		LD  R7,PU
		NOT R0,R0	      ;RESTA DE POSICIONES
		ADD R0,R0,#1          ;VERIFICA QUE NO SE COMPARE EL MISMO ESPACIO DE MEMORIA
		ADD R0,R7,R0          ;RESTO LOS DOS PUNTEROS QUE ESTOY UTILIZANDO			      
		BRZ POSIC             ;SI LA RESTA ES 0 SALTO A IGUALM
POSIN		AND R0,R0,#0
		LD R7,PIT	       ;SI LA RESTA DE LAS POSICIONES ES 0 Y LA RESTA DE LOS CATACTERES DA DIFERENTE A 0 QUIERE DECIR QUE ESTÁ EN UNA POSICIÓN INCORRECTA
		LDR R0,R7,#0
		ADD R0,R0,#1
		STR R0,R7,#0
		ADD R4,R4,#1          ;AUMENTO EL PUNTERO R4 PARA COMPARAR CON OTRO NUMERO         
		ADD R5,R5,#-1         ;
		BRZ CICLOT1            ;SI R5 ES 0 YA TERMINO DE COMPARAR UN DIGITO CON TODOS LOS DIGITOS Y VUELVE AL CICLO1
		BR  CICLOT2	      ;VUELVE A CICLO2 SI NO HA TERMINADO DE COMPARAR UN DIGITO CON LOS OTROS

POSIC		AND R0,R0,#0
		AND R7,R7,#0
		LD R7,PCT	       ;SI LA RESTA DE LAS POSICIONES ES 0 Y LA RESTA DE LOS CATACTERES DA DIFERENTE A 0 QUIERE DECIR QUE ESTÁ EN UNA POSICIÓN INCORRECTA
		LDR R0,R7,#0
		ADD R0,R0,#1
		STR R0,R7,#0
		ADD R4,R4,#1          ;AUMENTO EL PUNTERO R4 PARA COMPARAR CON OTRO NUMERO         
		ADD R5,R5,#-1         ;
		BRZ CICLOT1            ;SI R5 ES 0 YA TERMINO DE COMPARAR UN DIGITO CON TODOS LOS DIGITOS Y VUELVE AL CICLO1
		BR  CICLOT2	      ;VUELVE A CICLO2 SI NO HA TERMINADO DE COMPARAR UN DIGITO CON LOS OTROS
		

		;DECREMENTAMOS T PARA TERMINAR CON INTENTOS INGRESADOS POR EL USUARIO E IMPRIMIMOS POSICIONES CORRECTAS E INCORRECTAS
	

IMT		AND	R2,R2,#0
		LD	R2,PCT
		JSR	IMPOSICION
		LD	R2,PIT
		JSR	IMPOSICION


		AND R0,R0,#0
		LD      R0,MSGT10     ;posiciones correctas
	        PUTS 
		AND R0,R0,#0
		LD	R0,PCT
		PUTS
		AND R0,R0,#0
		LD      R0,MSGT11     ;posiciones incorrectas
	        PUTS
		AND R0,R0,#0 
		LD	R0,PIT
		PUTS
		
CTT2     .FILL  CT
MSGT13	 .FILL  MSG13

DEC		LD	R2,CTT2
		LDR	R1,R2,#0
		ADD	R1,R1,#1        ;SUMA 1 A LOS INTENTOS
		STR	R1,R2,#0
		
		AND	R1,R1,#0
		AND	R2,R2,#0        ;INICIALIZAMOS VARIABLES 
		AND 	R3,R3,#0
		LD	R2,TCC		;DIRECCIÓN DE LA TT
		LDR	R3,R2,#0	;CARGAMOS A R3 EL VALOR DE LOS INTENTOS
		ADD	R3,R3,#-1	;DISMINUIMOS DE A UNO Y VOLVEMOS A PEDIR UNA CLAVE AL USUARIO
		BRz	FINAL		;SI LLEGA A 0 YA CUMPLIÓ CON TODOS LOS INTENTOS
		STR	R3,R2,#0
		BR	USUING	

FELICITACIONES	LD      R0,MSGT9     ;GANÓ EL JUEGO
	        PUTS 
		LD	R0,CTT2
		PUTS
		LD	R0,MSGT13
		PUTS
		BR 	 FINAL

IMPOSICION	ST	R7,COPYR7T
		JSR	FUNC48
		ADD	R1,R1,#10      ;R1 ALMACENA 58 QUE ES IGUAL A ":" EN ASCCI, ESTE ES UN LIMITE
		AND	R3,R3,#0
		AND	R5,R5,#0
		STR	R5,R2,#1
		LDR	R3,R2,#0
		NOT	R5,R1
		ADD	R5,R5,#1      
		ADD	R5,R3,R5
		BRn	RPI	
		JSR	FUNC48
		ADD	R1,R1,#1
		STR	R1,R2,#0
		JSR	FUNC48
		ADD	R1,R1,R5
		STR	R1,R2,#1		
RPI		LD	R7,COPYR7T
		RET

FINAL	LD      R0,MSGT12     ;GANÓ EL JUEGO
	PUTS
	AND	R1,R1,#0
	GETC
	ADD	R1,R0,-10
	BRz	CLEAR	



        HALT

MSG0	.STRINGZ "\n----------------------MASTERMIND--------------------- "
MSGI	.STRINGZ "\n\n- Numero de digitos entre 04-15\n- Numero de intentos entre 05-12\n- Caracteres del juego [0,1,2,3,4,5,6,7,8,9,A,B,C,D,E] \n- Recordar no repetir caracteres en el codigo"	
MSG1    .STRINGZ "\n\n\nNumero de digitos: "
MSG2	.STRINGZ "\nNumero de intentos: "
MSG3	.STRINGZ "\nCodigo Secreto: "
MSG4	.STRINGZ "\nEl numero no está en el rango "
MSG5	.STRINGZ "\nError en numero de intentos "
MSG6	.STRINGZ "\nError digitos repetidos en la secuencia "
MSG7	.STRINGZ "\nLos dijitos ingresados no están en el rango asignado "
MSG8	.STRINGZ "\n\nCodigo jugador: "
MSG9	.STRINGZ "\n\nFELICITACIONES, GANASTE CON "
MSG13   .STRINGZ " INTENTOS"
MSG10	.STRINGZ "\nPosiciones correctas: "
MSG11	.STRINGZ "\nPosiciones incorrectas: "
MSG12   .STRINGZ "\n\nSi quieres volver a jugar oprime enter, de lo contrario cualquier otra tecla"
STRINGN .BLKW    3
STRINGN1 .BLKW 	 9
PC	.BLKW	3
PI	.BLKW	3
COPYR7  .BLKW	1
N	.FILL 1
T	.FILL 1
DATA	  .BLKW	 16
DATAU	  .BLKW	 16
ASTE	.BLKW	2
CT      .BLKW   1
        .END

